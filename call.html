<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Video Call</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            margin-bottom: 20px;
            color: #4CAF50;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 600px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
        }

        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            background: #333;
            color: #fff;
            border-radius: 5px;
            font-size: 16px;
        }

        button {
            padding: 12px 24px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
            position: relative;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .btn-secondary.disabled {
            background: #666;
            opacity: 0.6;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            background: #666;
        }

        .btn-small:hover {
            background: #777;
        }

        .btn-status {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #2a2a2a;
        }

        .btn-status.active {
            background: #4CAF50;
        }

        .btn-status.inactive {
            background: #f44336;
        }

        #status {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            text-align: center;
        }

        #diagnostics {
            margin: 10px 0;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 5px;
            font-size: 12px;
            color: #888;
            max-height: 150px;
            overflow-y: auto;
        }

        .diagnostic-line {
            margin: 3px 0;
        }

        .diagnostic-error {
            color: #f44336;
        }

        .diagnostic-success {
            color: #4CAF50;
        }

        .diagnostic-warning {
            color: #ff9800;
        }

        .videos {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        video {
            width: 100%;
            max-width: 500px;
            height: auto;
            display: block;
        }

        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .audio-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mic-icon {
            font-size: 20px;
        }

        .mic-bars {
            display: flex;
            gap: 3px;
            align-items: flex-end;
            height: 30px;
            flex: 1;
        }

        .mic-bar {
            flex: 1;
            background: #333;
            border-radius: 2px;
            transition: background 0.1s, height 0.1s;
            min-height: 4px;
        }

        .mic-bar.active {
            background: #4CAF50;
        }

        .hidden {
            display: none;
        }

        #myPeerId {
            word-break: break-all;
            background: #444;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            letter-spacing: 4px;
            color: #4CAF50;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        #peerIdInput {
            text-transform: uppercase;
            text-align: center;
            font-size: 20px;
            letter-spacing: 2px;
        }

        .code-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .code-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¥ Simple Video Call</h1>

    <div class="controls">
        <div id="status">Initializing...</div>
        <div id="diagnostics"></div>

        <div id="setup">
            <div class="input-group">
                <label>Your Code (share this):</label>
                <div class="code-container">
                    <div class="code-display">
                        <div id="myPeerId">------</div>
                    </div>
                    <button class="btn-small" onclick="generateNewCode()">Generate New Code</button>
                </div>
            </div>

            <div class="input-group">
                <label for="peerIdInput">Enter their code:</label>
                <input type="text" id="peerIdInput" placeholder="ABC123" maxlength="6">
            </div>

            <button class="btn-primary" onclick="startCall()">Start Call</button>
        </div>

        <div id="callControls" class="hidden">
            <div class="button-group">
                <button class="btn-danger" onclick="endCall()">End Call</button>
                <button class="btn-secondary" id="videoBtn" onclick="toggleVideo()">
                    <span class="btn-status active"></span>
                    Video
                </button>
                <button class="btn-secondary" id="audioBtn" onclick="toggleAudio()">
                    <span class="btn-status active"></span>
                    Audio
                </button>
            </div>
        </div>
    </div>

    <div class="videos">
        <div class="video-container">
            <div class="video-label">You</div>
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="audio-indicator" id="localAudioIndicator">
                <span class="mic-icon">ðŸŽ¤</span>
                <div class="mic-bars">
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                </div>
            </div>
        </div>
        <div class="video-container hidden" id="remoteContainer">
            <div class="video-label">Other Person</div>
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="audio-indicator" id="remoteAudioIndicator">
                <span class="mic-icon">ðŸŽ¤</span>
                <div class="mic-bars">
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                    <div class="mic-bar"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        let peer;
        let localStream;
        let currentCall;
        let isVideoEnabled = true;
        let isAudioEnabled = true;
        let localAudioContext;
        let localAnalyser;
        let remoteAudioContext;
        let remoteAnalyser;
        let animationFrameId;
        let myShortId;

        const STORAGE_KEY = 'videocall_peer_id';

        // Diagnostic logging
        function logDiagnostic(message, type = 'info') {
            console.log(`[${type.toUpperCase()}] ${message}`);
            const diagnosticsDiv = document.getElementById('diagnostics');
            const line = document.createElement('div');
            line.className = `diagnostic-line diagnostic-${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            diagnosticsDiv.appendChild(line);
            diagnosticsDiv.scrollTop = diagnosticsDiv.scrollHeight;
        }

        // Generate a random 6-character alphanumeric code
        function generateShortId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Get stored ID or generate new one
        function getOrCreateId() {
            let storedId = localStorage.getItem(STORAGE_KEY);
            if (storedId && storedId.length === 6) {
                logDiagnostic(`Loaded saved ID: ${storedId}`, 'success');
                return storedId;
            }
            const newId = generateShortId();
            localStorage.setItem(STORAGE_KEY, newId);
            logDiagnostic(`Generated new ID: ${newId}`, 'success');
            return newId;
        }

        // Generate new code (user requested)
        function generateNewCode() {
            if (currentCall) {
                alert('Please end the current call first');
                return;
            }
            
            const newId = generateShortId();
            localStorage.setItem(STORAGE_KEY, newId);
            logDiagnostic(`User requested new ID: ${newId}`, 'warning');
            
            // Destroy old peer and create new one
            if (peer) {
                peer.destroy();
            }
            
            myShortId = newId;
            document.getElementById('myPeerId').textContent = newId;
            document.getElementById('status').textContent = 'Generating new code...';
            
            // Reinitialize with new ID
            init();
        }

        // Initialize PeerJS with STUN/TURN servers
        async function init() {
            try {
                logDiagnostic('Initializing PeerJS...', 'info');
                
                // Get or create persistent ID
                myShortId = getOrCreateId();
                
                // Configure with multiple STUN/TURN servers for better connectivity
                const config = {
                    debug: 2,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' },
                            // Free TURN server (limited)
                            {
                                urls: 'turn:openrelay.metered.ca:80',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            },
                            {
                                urls: 'turn:openrelay.metered.ca:443',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            }
                        ],
                        iceTransportPolicy: 'all', // Try all methods
                        iceCandidatePoolSize: 10
                    }
                };

                // Create a new peer with our stored/generated ID
                peer = new Peer(myShortId, config);

                peer.on('open', (id) => {
                    document.getElementById('myPeerId').textContent = id;
                    document.getElementById('status').textContent = 'Ready! Share your code with the other person.';
                    logDiagnostic('Peer connection opened successfully', 'success');
                });

                peer.on('error', (error) => {
                    console.error('Peer error:', error);
                    logDiagnostic(`Peer error: ${error.type} - ${error.message}`, 'error');
                    
                    // If ID is taken, generate a new one and store it
                    if (error.type === 'unavailable-id') {
                        document.getElementById('status').textContent = 'Code conflict, generating new one...';
                        const newId = generateShortId();
                        localStorage.setItem(STORAGE_KEY, newId);
                        myShortId = newId;
                        peer = new Peer(myShortId, config);
                        // Re-attach event listeners
                        attachPeerListeners();
                    } else {
                        document.getElementById('status').textContent = 'Error: ' + error.message;
                    }
                });

                attachPeerListeners();

            } catch (error) {
                console.error('Initialization error:', error);
                logDiagnostic(`Initialization error: ${error.message}`, 'error');
                document.getElementById('status').textContent = 'Error initializing: ' + error.message;
            }
        }

        // Attach peer event listeners
        function attachPeerListeners() {
            peer.on('open', (id) => {
                document.getElementById('myPeerId').textContent = id;
                document.getElementById('status').textContent = 'Ready! Share your code with the other person.';
                logDiagnostic('Ready to receive calls', 'success');
            });

            // Handle incoming calls
            peer.on('call', async (call) => {
                logDiagnostic('Incoming call detected', 'info');
                document.getElementById('status').textContent = 'Incoming call...';
                
                // Get local stream
                if (!localStream) {
                    logDiagnostic('Getting local media stream...', 'info');
                    await getLocalStream();
                }

                // Answer the call with our stream
                logDiagnostic('Answering call with local stream', 'info');
                call.answer(localStream);
                currentCall = call;

                // Monitor connection state
                if (call.peerConnection) {
                    call.peerConnection.oniceconnectionstatechange = () => {
                        logDiagnostic(`ICE connection state: ${call.peerConnection.iceConnectionState}`, 'info');
                    };
                    
                    call.peerConnection.onconnectionstatechange = () => {
                        logDiagnostic(`Connection state: ${call.peerConnection.connectionState}`, 'info');
                    };
                }

                // Handle the remote stream
                call.on('stream', (remoteStream) => {
                    logDiagnostic('Remote stream received!', 'success');
                    logDiagnostic(`Remote stream has ${remoteStream.getVideoTracks().length} video tracks and ${remoteStream.getAudioTracks().length} audio tracks`, 'info');
                    
                    document.getElementById('remoteVideo').srcObject = remoteStream;
                    document.getElementById('remoteContainer').classList.remove('hidden');
                    document.getElementById('status').textContent = 'Connected!';
                    document.getElementById('setup').classList.add('hidden');
                    document.getElementById('callControls').classList.remove('hidden');
                    
                    // Setup audio visualization for remote stream
                    setupAudioVisualization(remoteStream, 'remote');
                });

                call.on('close', () => {
                    logDiagnostic('Call closed', 'warning');
                    endCall();
                });

                call.on('error', (error) => {
                    logDiagnostic(`Call error: ${error.message}`, 'error');
                });
            });

            peer.on('disconnected', () => {
                logDiagnostic('Peer disconnected from server', 'warning');
            });

            peer.on('close', () => {
                logDiagnostic('Peer connection closed', 'warning');
            });
        }

        // Get local video/audio stream
        async function getLocalStream() {
            try {
                logDiagnostic('Requesting camera and microphone access...', 'info');
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                logDiagnostic(`Local stream obtained: ${localStream.getVideoTracks().length} video, ${localStream.getAudioTracks().length} audio`, 'success');
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // Log track details
                localStream.getTracks().forEach(track => {
                    logDiagnostic(`Track: ${track.kind} - ${track.label} (enabled: ${track.enabled})`, 'info');
                });
                
                // Setup audio visualization for local stream
                setupAudioVisualization(localStream, 'local');
                
                return localStream;
            } catch (error) {
                console.error('Error accessing media devices:', error);
                logDiagnostic(`Media access error: ${error.name} - ${error.message}`, 'error');
                alert('Could not access camera/microphone. Please grant permissions and try again.');
                throw error;
            }
        }

        // Setup audio visualization
        function setupAudioVisualization(stream, type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                
                analyser.fftSize = 256;
                source.connect(analyser);
                
                if (type === 'local') {
                    localAudioContext = audioContext;
                    localAnalyser = analyser;
                    logDiagnostic('Local audio visualization setup', 'success');
                } else {
                    remoteAudioContext = audioContext;
                    remoteAnalyser = analyser;
                    logDiagnostic('Remote audio visualization setup', 'success');
                }
                
                // Start visualization
                if (!animationFrameId) {
                    visualizeAudio();
                }
            } catch (error) {
                logDiagnostic(`Audio visualization error: ${error.message}`, 'error');
            }
        }

        // Visualize audio levels
        function visualizeAudio() {
            animationFrameId = requestAnimationFrame(visualizeAudio);
            
            // Visualize local audio
            if (localAnalyser && isAudioEnabled) {
                const dataArray = new Uint8Array(localAnalyser.frequencyBinCount);
                localAnalyser.getByteFrequencyData(dataArray);
                updateBars('localAudioIndicator', dataArray);
            } else {
                clearBars('localAudioIndicator');
            }
            
            // Visualize remote audio
            if (remoteAnalyser) {
                const dataArray = new Uint8Array(remoteAnalyser.frequencyBinCount);
                remoteAnalyser.getByteFrequencyData(dataArray);
                updateBars('remoteAudioIndicator', dataArray);
            }
        }

        // Update audio bars
        function updateBars(indicatorId, dataArray) {
            const indicator = document.getElementById(indicatorId);
            const bars = indicator.querySelectorAll('.mic-bar');
            
            // Calculate average volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            
            // Update each bar based on volume level
            bars.forEach((bar, index) => {
                const threshold = (index + 1) * (255 / bars.length);
                if (average > threshold) {
                    bar.classList.add('active');
                    bar.style.height = Math.min(100, (average / 255) * 100) + '%';
                } else {
                    bar.classList.remove('active');
                    bar.style.height = '4px';
                }
            });
        }

        // Clear audio bars
        function clearBars(indicatorId) {
            const indicator = document.getElementById(indicatorId);
            const bars = indicator.querySelectorAll('.mic-bar');
            bars.forEach(bar => {
                bar.classList.remove('active');
                bar.style.height = '4px';
            });
        }

        // Start a call to another peer
        async function startCall() {
            let remotePeerId = document.getElementById('peerIdInput').value.trim().toUpperCase();
            
            if (!remotePeerId) {
                alert('Please enter the other person\'s code');
                return;
            }

            if (remotePeerId.length !== 6) {
                alert('Code must be exactly 6 characters');
                return;
            }

            logDiagnostic(`Attempting to call ${remotePeerId}`, 'info');
            document.getElementById('status').textContent = 'Connecting...';

            try {
                // Get local stream if we don't have it
                if (!localStream) {
                    logDiagnostic('Getting local media stream...', 'info');
                    await getLocalStream();
                }

                // Make the call
                logDiagnostic('Initiating call...', 'info');
                currentCall = peer.call(remotePeerId, localStream);

                if (!currentCall) {
                    throw new Error('Failed to initiate call');
                }

                logDiagnostic('Call initiated, waiting for response...', 'info');

                // Monitor connection state
                if (currentCall.peerConnection) {
                    currentCall.peerConnection.oniceconnectionstatechange = () => {
                        logDiagnostic(`ICE connection state: ${currentCall.peerConnection.iceConnectionState}`, 'info');
                    };
                    
                    currentCall.peerConnection.onconnectionstatechange = () => {
                        logDiagnostic(`Connection state: ${currentCall.peerConnection.connectionState}`, 'info');
                    };

                    currentCall.peerConnection.onicegatheringstatechange = () => {
                        logDiagnostic(`ICE gathering state: ${currentCall.peerConnection.iceGatheringState}`, 'info');
                    };
                }

                // Handle the remote stream
                currentCall.on('stream', (remoteStream) => {
                    logDiagnostic('Remote stream received!', 'success');
                    logDiagnostic(`Remote stream has ${remoteStream.getVideoTracks().length} video tracks and ${remoteStream.getAudioTracks().length} audio tracks`, 'info');
                    
                    document.getElementById('remoteVideo').srcObject = remoteStream;
                    document.getElementById('remoteContainer').classList.remove('hidden');
                    document.getElementById('status').textContent = 'Connected!';
                    document.getElementById('setup').classList.add('hidden');
                    document.getElementById('callControls').classList.remove('hidden');
                    
                    // Setup audio visualization for remote stream
                    setupAudioVisualization(remoteStream, 'remote');
                });

                currentCall.on('close', () => {
                    logDiagnostic('Call closed by remote peer', 'warning');
                    endCall();
                });

                currentCall.on('error', (error) => {
                    console.error('Call error:', error);
                    logDiagnostic(`Call error: ${error.type} - ${error.message}`, 'error');
                    document.getElementById('status').textContent = 'Call failed: ' + error.message;
                    endCall();
                });

            } catch (error) {
                console.error('Error starting call:', error);
                logDiagnostic(`Failed to start call: ${error.message}`, 'error');
                document.getElementById('status').textContent = 'Failed to start call: ' + error.message;
            }
        }

        // End the current call
        function endCall() {
            logDiagnostic('Ending call...', 'info');
            
            if (currentCall) {
                currentCall.close();
            }

            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    logDiagnostic(`Stopped ${track.kind} track`, 'info');
                });
                localStream = null;
            }

            // Stop audio visualization
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Close audio contexts
            if (localAudioContext) {
                localAudioContext.close();
                localAudioContext = null;
                localAnalyser = null;
            }
            if (remoteAudioContext) {
                remoteAudioContext.close();
                remoteAudioContext = null;
                remoteAnalyser = null;
            }

            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
            document.getElementById('remoteContainer').classList.add('hidden');
            document.getElementById('setup').classList.remove('hidden');
            document.getElementById('callControls').classList.add('hidden');
            document.getElementById('status').textContent = 'Call ended. Ready for next call.';
            
            // Reset button states
            isVideoEnabled = true;
            isAudioEnabled = true;
            updateButtonStatus();
            
            currentCall = null;
            
            logDiagnostic('Call ended, ready for new call', 'success');
        }

        // Toggle video on/off
        function toggleVideo() {
            if (localStream) {
                isVideoEnabled = !isVideoEnabled;
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = isVideoEnabled;
                });
                updateButtonStatus();
                logDiagnostic(`Video ${isVideoEnabled ? 'enabled' : 'disabled'}`, 'info');
            }
        }

        // Toggle audio on/off
        function toggleAudio() {
            if (localStream) {
                isAudioEnabled = !isAudioEnabled;
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = isAudioEnabled;
                });
                updateButtonStatus();
                logDiagnostic(`Audio ${isAudioEnabled ? 'enabled' : 'disabled'}`, 'info');
                
                // Clear bars when audio is disabled
                if (!isAudioEnabled) {
                    clearBars('localAudioIndicator');
                }
            }
        }

        // Update button status indicators
        function updateButtonStatus() {
            const videoBtn = document.getElementById('videoBtn');
            const audioBtn = document.getElementById('audioBtn');
            
            const videoStatus = videoBtn.querySelector('.btn-status');
            const audioStatus = audioBtn.querySelector('.btn-status');
            
            if (isVideoEnabled) {
                videoStatus.classList.remove('inactive');
                videoStatus.classList.add('active');
                videoBtn.classList.remove('disabled');
            } else {
                videoStatus.classList.remove('active');
                videoStatus.classList.add('inactive');
                videoBtn.classList.add('disabled');
            }
            
            if (isAudioEnabled) {
                audioStatus.classList.remove('inactive');
                audioStatus.classList.add('active');
                audioBtn.classList.remove('disabled');
            } else {
                audioStatus.classList.remove('active');
                audioStatus.classList.add('inactive');
                audioBtn.classList.add('disabled');
            }
        }

        // Initialize on page load
        init();
    </script>
</body>
</html>
